"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var GeneratorUtils = (function () {
    function GeneratorUtils() {
    }
    GeneratorUtils.bufferToUint64 = function (input) {
        if (8 !== input.length) {
            throw Error("byte array has unexpected size '" + input.length + "'");
        }
        input = input.reverse();
        var view = new DataView(input.buffer);
        return [view.getUint32(4), view.getUint32(0)];
    };
    GeneratorUtils.readUint32At = function (bytes, index) {
        return (bytes[index] + (bytes[index + 1] << 8) + (bytes[index + 2] << 16) + (bytes[index + 3] << 24)) >>> 0;
    };
    GeneratorUtils.uintToBuffer = function (uintValue, bufferSize) {
        var buffer = new ArrayBuffer(bufferSize);
        var dataView = new DataView(buffer);
        try {
            if (1 === bufferSize) {
                dataView.setUint8(0, uintValue);
            }
            else if (2 === bufferSize) {
                dataView.setUint16(0, uintValue, true);
            }
            else if (4 === bufferSize) {
                dataView.setUint32(0, uintValue, true);
            }
            else {
                throw new Error('Unexpected bufferSize');
            }
            return new Uint8Array(buffer);
        }
        catch (e) {
            throw new Error("Converting uint value " + uintValue + " into buffer with error: " + e);
        }
    };
    GeneratorUtils.bufferToUint = function (buffer) {
        var dataView = new DataView(buffer.buffer);
        try {
            if (1 === buffer.byteLength) {
                return dataView.getUint8(0);
            }
            else if (2 === buffer.byteLength) {
                return dataView.getUint16(0, true);
            }
            else if (4 === buffer.byteLength) {
                return dataView.getUint32(0, true);
            }
            throw new Error('Unexpected buffer size');
        }
        catch (e) {
            throw new Error("Converting buffer into number with error: " + e);
        }
    };
    GeneratorUtils.uint64ToBuffer = function (uintValue) {
        var uint32Array = new Uint32Array(uintValue);
        return new Uint8Array(uint32Array.buffer);
    };
    GeneratorUtils.concatTypedArrays = function (array1, array2) {
        var newArray = new Uint8Array(array1.length + array2.length);
        newArray.set(array1);
        newArray.set(array2, array1.length);
        return newArray;
    };
    GeneratorUtils.getBytes = function (binary, size) {
        if (size > binary.length) {
            throw new RangeError();
        }
        var bytes = binary.slice(0, size);
        return bytes;
    };
    GeneratorUtils.getTransactionPaddingSize = function (size, alignment) {
        return 0 === size % alignment ? 0 : alignment - (size % alignment);
    };
    GeneratorUtils.compact = function (uint64) {
        var low = uint64[0];
        var high = uint64[1];
        if (0x00200000 <= high) {
            return uint64;
        }
        return (high * 0x100000000) + low;
    };
    GeneratorUtils.fromUint = function (number) {
        var value = [(number & 0xFFFFFFFF) >>> 0, (number / 0x100000000) >>> 0];
        return value;
    };
    GeneratorUtils.uint8ToInt8 = function (input) {
        if (0xFF < input) {
            throw Error("input '" + input + "' is out of range");
        }
        return input << 24 >> 24;
    };
    return GeneratorUtils;
}());
exports.GeneratorUtils = GeneratorUtils;
//# sourceMappingURL=GeneratorUtils.js.map